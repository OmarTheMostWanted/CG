<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Exercise set 1 : Intro to Opengl</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {  background-color: #f8f8f8; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ef2929; } /* Alert */
    code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #204a87; } /* Attribute */
    code span.bn { color: #0000cf; } /* BaseN */
    code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4e9a06; } /* Char */
    code span.cn { color: #8f5902; } /* Constant */
    code span.co { color: #8f5902; font-style: italic; } /* Comment */
    code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
    code span.dt { color: #204a87; } /* DataType */
    code span.dv { color: #0000cf; } /* DecVal */
    code span.er { color: #a40000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #0000cf; } /* Float */
    code span.fu { color: #204a87; font-weight: bold; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
    code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
    code span.ot { color: #8f5902; } /* Other */
    code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
    code span.sc { color: #ce5c00; font-weight: bold; } /* SpecialChar */
    code span.ss { color: #4e9a06; } /* SpecialString */
    code span.st { color: #4e9a06; } /* String */
    code span.va { color: #000000; } /* Variable */
    code span.vs { color: #4e9a06; } /* VerbatimString */
    code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <style>
/*
 * Slightly modified version of the following theme:;
 * https://github.com/markdowncss/air
 */
html {
  font-size: 12px;
}

@media print {
  *:before,
  *:after {
    background: transparent !important;
    color: #000 !important;
    box-shadow: none !important;
    text-shadow: none !important;
  }

  html {
    font-size: 14px;
  }
  body {
    padding-left: 4rem;
    padding-right: 4rem;
  }

  a,
  a:visited {
    text-decoration: underline;
  }

  a[href]:after {
    content: " (" attr(href) ")";
  }

  abbr[title]:after {
    content: " (" attr(title) ")";
  }

  a[href^="#"]:after,
  a[href^="javascript:"]:after {
    content: "";
  }

  pre,
  blockquote {
    border: 1px solid #999;
    page-break-inside: avoid;
  }

  thead {
    display: table-header-group;
  }

  tr,
  img {
    page-break-inside: avoid;
  }

  img {
    max-width: 100% !important;
  }

  p,
  h2,
  h3 {
    orphans: 3;
    widows: 3;
  }

  h2,
  h3 {
    page-break-after: avoid;
  }
}

@media screen and (min-width: 32rem) and (max-width: 48rem) {
  html {
    font-size: 15px;
  }
}

@media screen and (min-width: 48rem) {
  html {
    font-size: 16px;
  }
}

body {
  line-height: 1.85;
  padding-bottom: 2rem;
}

p,
.air-p {
  font-size: 1rem;
  margin-bottom: 1.3rem;
}

h1,
.air-h1,
h2,
.air-h2,
h3,
.air-h3,
h4,
.air-h4 {
  margin: 1.414rem 0 .5rem;
  font-weight: inherit;
  line-height: 1.42;
}

h1,
.air-h1 {
  margin-top: 0;
  font-size: 3.998rem;
}

h2,
.air-h2 {
  font-size: 2.827rem;
}

h3,
.air-h3 {
  font-size: 1.999rem;
}

h4,
.air-h4 {
  font-size: 1.414rem;
}

h5,
.air-h5 {
  font-size: 1.121rem;
}

h6,
.air-h6 {
  font-size: .88rem;
}

small,
.air-small {
  font-size: .707em;
}

/* https://github.com/mrmrs/fluidity */

img,
canvas,
iframe,
video,
svg,
select,
textarea {
  display: block;
  margin-left: auto;
  margin-right: auto;

  max-width: 100%;
}

figcaption {
  text-align: center;
}
.subfigures {
  text-align: center;
}
.subfigures figure {
  float: left;
  width: 50%;
  margin:0;
  display: inline-block;
}
.subfigures img {
  display: inline-block;
  width: 90%;
}
.subfigures figure figcaption {
  display: inline-block;
}

@import url(http://fonts.googleapis.com/css?family=Open+Sans:300italic,300);

body {
  color: #444;
  font-family: 'Open Sans', Helvetica, sans-serif;
  font-weight: 300;
  margin: 6rem auto 1rem;
  max-width: 48rem;
  text-align: justify;
}

/*img {
  border-radius: 50%;
  height: 200px;
  margin: 0 auto;
  width: 200px;
}*/

a,
a:visited {
  color: #3498db;
}

a:hover,
a:focus,
a:active {
  color: #2980b9;
}

pre:not(.sourceCode) {
  background-color: #fafafa;
}
pre {
  padding: 1rem;
  text-align: left;
}

blockquote {
  margin: 0;
  border-left: 5px solid #7a7a7a;
  font-style: italic;
  padding: 1.33em;
  text-align: left;
}

ul,
ol,
li {
  text-align: left;
}

p {
  color: #777;
}

/*
 * Copied from w3schools.com:
 * https://www.w3schools.com/css/css_table.asp
 *
 * Table header colour changed to CGV home style (taken from CGV Powerpoint template)
 */
table {
  border-collapse: collapse;
  width: 100%;
}
table td, table th {
  border: 1px solid #ddd;
  padding: 8px;
}
table tr:nth-child(even){background-color: #f2f2f2;}
/* table tr:hover {background-color: #ddd;} */
table th {
  padding-top: 12px;
  padding-bottom: 12px;
  text-align: left;
  background-color: #10A5D7;
  color: white;
}


</style>
  <div style="overflow:auto;">
  	<p style="float:left;margin:0;"><b>CS4515</b> - 3D Computer Graphics and Animation</p><p style="float:right;margin:0;">Elmar Eisemann, Ricardo Marroqium</p>
  </div>

  <hr>
  <br/>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Exercise set 1 : Intro to Opengl</h1>
</header>
<p>Welcome to 3DCGA! In this first exercise set of the course, you will
learn the basics of graphics programming with Legacy OpenGL, and you
will get some hands-on experience with using the <code>glm</code>
library for working with 3D transformations.</p>
<p>These exercises comes with a corresponding C++ code template, which
is heavily commented with instructions on what to implement. The
<code>main.cpp</code> file contains five functions left blank which you
will implement throughout this exercise set.</p>
<h2 id="background-imgui">Background: <code>ImGui</code></h2>
<p>This, and the following exercises and assignments use the <a
href="https://github.com/ocornut/imgui">Dear ImGui</a> library for
creating interactive UIs. When you run the application you should see a
UI window with some controls. The window can be hidden/shown by pressing
the backslash (<code>\</code>) key.</p>
<p>The layout of this UI window is declared in the <code>imgui</code>
function in <code>main.cpp</code>, and you are free to modify it in
this, and the following exercises and assignments to create useful
widgets to control and debug the live state of your applications. We
have also included some dummy controls that you can use as a base for
implementing your custom controls.</p>
<h2 id="background-rendering-with-legacy-opengl">Background: Rendering
with legacy OpenGL</h2>
<p>In these exercises, we will use the legacy OpenGL (version 2.1)
commands for rendering 3D shapes to the screen. Later, we will cover the
more complex, but more flexible modern OpenGL pipeline.</p>
<p>To draw a primitive shape, such as a triangle, we need to specify its
properties in a<code>glBegin(PRIMITIVE_ID)</code>/<code>glEnd()</code>
block. For example, to render a triangle, you can write:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>glBegin<span class="op">(</span>GL_TRIANGLES<span class="op">);</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>glVertex3f<span class="op">(</span>x0<span class="op">,</span> y0<span class="op">,</span> z0<span class="op">);</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>glVertex3f<span class="op">(</span>x1<span class="op">,</span> y1<span class="op">,</span> z1<span class="op">);</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>glVertex3f<span class="op">(</span>x2<span class="op">,</span> y2<span class="op">,</span> z2<span class="op">);</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>glEnd<span class="op">()</span></span></code></pre></div>
<p>Additionally, you can set properties for the entire primitive before
rendering, such as color and normal to modify the properties of the
primitive.</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>glColor3f<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>glNormal3f<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>glBegin<span class="op">(</span>GL_TRIANGLES<span class="op">);</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>glEnd<span class="op">();</span></span></code></pre></div>
<p>We don’t need much more for the sake of these exercises, but for more
information, see the <a
href="http://15462.courses.cs.cmu.edu/spring2018content/lectures/00_opengl/00_opengl_slides.pdf">CMU
OpenGL Tutorial</a>.</p>
<h1 id="exercise-1-triangle">Exercise 1: Triangle</h1>
<p>In this exercise, you will implement basic triangle rendering by
implementing the <code>drawTriangle</code> function. The function
should:</p>
<ol type="1">
<li>Render a triangle with arbitrary vertex positions</li>
<li>Add a second triangle in Blue, and make both triangles share their
first vertex</li>
<li>Add a global variable (initialized to 0) that represents the
x-coordinate of the first vertex of each triangle</li>
<li>Go to the function <code>animate</code> and increment this variable
by a small value on each iteration, observe the animation, alternatively
you can control this value with an ImGui widget</li>
</ol>
<h2 id="background-glm-opengl-math-library">Background: GLM OpenGL Math
Library</h2>
<p>In this exercise set we use <a
href="https://openframeworks.cc/documentation/glm/"><code>glm</code></a>
as a library for working with linear algebra. <code>glm</code> provides
classes for common mathematical objects and operations such as vectors,
and matrices:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Declare a 3-vector</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>glm<span class="op">::</span>vec3 vector <span class="op">=</span> glm<span class="op">::</span>vec3<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co">// create the 3x3 identity matrix</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>glm<span class="op">::</span>mat3 identity <span class="op">=</span> glm<span class="op">::</span>mat3<span class="op">(</span><span class="fl">1.0</span><span class="bu">f</span><span class="op">)</span></span></code></pre></div>
<p>Additionally, glm provides a lot of functions for working with these
objects, and overloads their operators allowing us to perform arithmetic
with them:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">// create a matrix with 2 on diagonals</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>glm<span class="op">::</span>mat3 scaleMatrix <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> identity<span class="op">;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co">// multiply the vector with the matrix</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>glm<span class="op">::</span>scaledVector <span class="op">=</span> vector <span class="op">*</span> scaleMatrix<span class="op">;</span></span></code></pre></div>
<p>In these exercises, you will mostly work with <code>glm::vec3</code>
objects for representing 3D points and vectors,<code>glm:vec4</code>
objects for representing points and vectors in homogeneous space, and
<code>glm::mat4</code> matrices for representing and applying 3D
translations, and rotations and scales on these points.</p>
<p>To construct transformation matrices, GLM provides the useful
<code>rotate</code>, <code>translate</code>, and <code>scale</code>.
They each take a base matrix as input, and a series of arguments
specifying the parameters of the rotation/translation/scale and output
the matrix that first applies the base transform, and then the specified
one:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">// initialize matrix as identity</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>glm<span class="op">::</span>mat4 transform <span class="op">=</span> glm<span class="op">::</span>mat4<span class="op">(</span><span class="fl">1.0</span><span class="bu">f</span><span class="op">);</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="co">// define translation, rotation, and scale</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>glm<span class="op">::</span>vec3 translationVector<span class="op">(</span><span class="fl">10.0</span><span class="bu">f</span><span class="op">,</span> <span class="fl">5.0</span><span class="bu">f</span><span class="op">,</span> <span class="fl">2.0</span><span class="bu">f</span><span class="op">);</span>  <span class="co">// translate by (10, 5, 2)</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>glm<span class="op">::</span>vec3 scaleVector<span class="op">(</span><span class="fl">2.0</span><span class="bu">f</span><span class="op">,</span> <span class="fl">2.0</span><span class="bu">f</span><span class="op">,</span> <span class="fl">2.0</span><span class="bu">f</span><span class="op">);</span>         <span class="co">// scale by a factor of 2 on all axes</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>glm<span class="op">::</span>vec3 rotationAxis<span class="op">(</span><span class="fl">0.0</span><span class="bu">f</span><span class="op">,</span> <span class="fl">1.0</span><span class="bu">f</span><span class="op">,</span> <span class="fl">0.0</span><span class="bu">f</span><span class="op">);</span>        <span class="co">// rotate around the y-axis</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> rotationAngle <span class="op">=</span> glm<span class="op">::</span>radians<span class="op">(</span><span class="fl">45.0</span><span class="bu">f</span><span class="op">);</span>       <span class="co">// rotate by 45 degrees</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="co">// apply scaling</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>transform <span class="op">=</span> glm<span class="op">::</span>scale<span class="op">(</span>transform<span class="op">,</span> scaleVector<span class="op">);</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a><span class="co">// apply rotation</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>transform <span class="op">=</span> glm<span class="op">::</span>rotate<span class="op">(</span>transform<span class="op">,</span> rotationAngle<span class="op">,</span> rotationAxis<span class="op">);</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a><span class="co">// apply translation</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>transform <span class="op">=</span> glm<span class="op">::</span>translate<span class="op">(</span>transform<span class="op">,</span> translationVector<span class="op">);</span></span></code></pre></div>
<p>Alternatively, you can separately construct the translation, rotation
and scale matrices by passing the identity matrix as the base matrix,
and then multiply them in reverse order at the end to obtain the
equivalent composed transform matrix:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>glm<span class="op">::</span>mat4 id <span class="op">=</span> glm<span class="op">::</span>vec4<span class="op">(</span><span class="fl">1.0</span><span class="bu">f</span><span class="op">);</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>glm<span class="op">::</span>mat4 scaleMatrix <span class="op">=</span> glm<span class="op">::</span>scale<span class="op">(</span>id<span class="op">,</span> scaleVector<span class="op">);</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>glm<span class="op">::</span>mat4 rotationMatrix <span class="op">=</span> glm<span class="op">::</span>rotate<span class="op">(</span>id<span class="op">,</span> rotationAngle<span class="op">,</span> rotationAxis<span class="op">);</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>glm<span class="op">::</span>mat4 translationMatrix <span class="op">=</span> glm<span class="op">::</span>translate<span class="op">(</span>id<span class="op">,</span> translationVector<span class="op">);</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="co">// combine the matrices by multiplying in reverse order</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>glm<span class="op">::</span>mat4 transform <span class="op">=</span> translationMatrix <span class="op">*</span> rotationMatrix <span class="op">*</span> scaleMatrix<span class="op">;</span></span></code></pre></div>
<h1 id="exercise-2-render-a-unit-face">Exercise 2: Render a Unit
Face</h1>
<p>Implement the function <code>drawUnitFace</code>. This function
should render a 1x1 quad to the screen. You can use the
<code>GL_QUADS</code> primitive, which works like the triangle primitive
but with a fourth vertex:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>glBegin<span class="op">(</span>GL_QUADS<span class="op">);</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>glVertex3f<span class="op">(</span>x1<span class="op">,</span> y1<span class="op">,</span> z1<span class="op">);</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>glVertex3f<span class="op">(</span>x2<span class="op">,</span> y2<span class="op">,</span> z2<span class="op">);</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>glVertex3f<span class="op">(</span>x3<span class="op">,</span> y3<span class="op">,</span> z3<span class="op">);</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>glVertex3f<span class="op">(</span>x4<span class="op">,</span> y4<span class="op">,</span> z4<span class="op">);</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>glEnd<span class="op">();</span></span></code></pre></div>
<p>Additionally, the function takes a <code>transformMatrix</code>
argument, which represents a glm 4x4 transform matrix. Modify your
implementation so that the quad is transformed according to this
matrix.</p>
<h1 id="exercise-3-render-a-unit-cube">Exercise 3: Render a Unit
Cube</h1>
<p>Implement the function <code>drawUnitCube</code>. This function
should render a 1x1x1 cube to the screen.</p>
<p>If you have implemented the previous exercise correctly, the most
straightforward implementation is to call <code>drawUnitFace</code> 6
times, once for each face, passing different transform matrices for each
call such that they make up a cube.</p>
<p>Additionally, like the previous exercise, this function takes a
transform matrix that should be applied to the whole cube. Modify your
implementation so that the cube is transformed according to this
matrix.</p>
<h1 id="exercise-4-render-an-animated-robot-arm.">Exercise 4: Render an
animated robot arm.</h1>
<p>Implement the function <code>drawArm</code>. This function should
render a three-unit arm with an upper arm, forearm, and hand, each
represented by a cube, and three joints representing the shoulder,
elbow, and wrist rotations.</p>
<p>Your robot arm should be controllable with two global variables:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">// scale vector of each part of the arm determines the arm shape</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="bu">std::</span>array armScale <span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    glm<span class="op">::</span>vec3<span class="op">(</span><span class="fl">0.5</span><span class="bu">f</span><span class="op">,</span> <span class="fl">0.5</span><span class="bu">f</span><span class="op">,</span> <span class="fl">1.0</span><span class="bu">f</span><span class="op">),</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    glm<span class="op">::</span>vec3<span class="op">(</span><span class="fl">0.3</span><span class="bu">f</span><span class="op">,</span> <span class="fl">0.3</span><span class="bu">f</span><span class="op">,</span> <span class="fl">0.8</span><span class="bu">f</span><span class="op">),</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    glm<span class="op">::</span>vec3<span class="op">(</span><span class="fl">0.6</span><span class="bu">f</span><span class="op">,</span> <span class="fl">0.6</span><span class="bu">f</span><span class="op">,</span> <span class="fl">0.6</span><span class="bu">f</span><span class="op">)</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="co">// rotation of each part of the arm, determines the arm pose</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>array arm_joint <span class="op">{</span> <span class="fl">0.5</span><span class="bu">f</span><span class="op">,</span> <span class="op">-</span><span class="fl">0.3</span><span class="bu">f</span><span class="op">,</span> <span class="op">-</span><span class="fl">0.4</span><span class="bu">f</span> <span class="op">};</span></span></code></pre></div>
<p>You can debug your implementation by controlling the joint states
with the UI or modifying them in the animate function.</p>
<p>Take care of ensuring the order of transformations is correct, such
that the arm always remains connected, and each joint affects the
following joints:</p>
<h1 id="exercise-5-draw-light">Exercise 5: Draw Light</h1>
<p>Implement the <code>drawLight</code> function. This function should
draw a small placeholder cube at the light source position so that you
can visualize it.</p>
<p>Additionally, make the light position controllable, either via
keyboard (WASD) or ImGui controls. Lighting can be toggled with the
<code>l/L</code> keys or through the UI.</p>
<p>Lastly, if you haven’t done-so already, add normal information to all
your faces in the previous functions and observe how they are properly
shaded by the light.</p>
<h1 id="exercise-6-render-a-triangle-mesh">Exercise 6: Render a Triangle
Mesh</h1>
<p>Finally, implement the <code>drawMesh</code> function. This function
should iterate over the triangles in a mesh and display them
separately.</p>
<ul>
<li>Make sure you compute the normals of each face</li>
<li>Try computing a normal per vertex, as the average of the adjacent
face normals (you can call <code>glNormal3f</code> before each vertex),
this should change how the model is lit</li>
<li>Try loading your own <code>obj</code> model by replacing the
provided mesh file</li>
</ul>
</body>
</html>
