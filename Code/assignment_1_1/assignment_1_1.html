<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Basic Graphics Techniques</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {  background-color: #f8f8f8; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ef2929; } /* Alert */
    code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #c4a000; } /* Attribute */
    code span.bn { color: #0000cf; } /* BaseN */
    code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4e9a06; } /* Char */
    code span.cn { color: #000000; } /* Constant */
    code span.co { color: #8f5902; font-style: italic; } /* Comment */
    code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
    code span.dt { color: #204a87; } /* DataType */
    code span.dv { color: #0000cf; } /* DecVal */
    code span.er { color: #a40000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #0000cf; } /* Float */
    code span.fu { color: #000000; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
    code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
    code span.ot { color: #8f5902; } /* Other */
    code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
    code span.sc { color: #000000; } /* SpecialChar */
    code span.ss { color: #4e9a06; } /* SpecialString */
    code span.st { color: #4e9a06; } /* String */
    code span.va { color: #000000; } /* Variable */
    code span.vs { color: #4e9a06; } /* VerbatimString */
    code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <style>
/*
 * Slightly modified version of the following theme:;
 * https://github.com/markdowncss/air
 */
html {
  font-size: 12px;
}

@media print {
  *:before,
  *:after {
    background: transparent !important;
    color: #000 !important;
    box-shadow: none !important;
    text-shadow: none !important;
  }

  html {
    font-size: 14px;
  }
  body {
    padding-left: 4rem;
    padding-right: 4rem;
  }

  a,
  a:visited {
    text-decoration: underline;
  }

  a[href]:after {
    content: " (" attr(href) ")";
  }

  abbr[title]:after {
    content: " (" attr(title) ")";
  }

  a[href^="#"]:after,
  a[href^="javascript:"]:after {
    content: "";
  }

  pre,
  blockquote {
    border: 1px solid #999;
    page-break-inside: avoid;
  }

  thead {
    display: table-header-group;
  }

  tr,
  img {
    page-break-inside: avoid;
  }

  img {
    max-width: 100% !important;
  }

  p,
  h2,
  h3 {
    orphans: 3;
    widows: 3;
  }

  h2,
  h3 {
    page-break-after: avoid;
  }
}

@media screen and (min-width: 32rem) and (max-width: 48rem) {
  html {
    font-size: 15px;
  }
}

@media screen and (min-width: 48rem) {
  html {
    font-size: 16px;
  }
}

body {
  line-height: 1.85;
  padding-bottom: 2rem;
}

p,
.air-p {
  font-size: 1rem;
  margin-bottom: 1.3rem;
}

h1,
.air-h1,
h2,
.air-h2,
h3,
.air-h3,
h4,
.air-h4 {
  margin: 1.414rem 0 .5rem;
  font-weight: inherit;
  line-height: 1.42;
}

h1,
.air-h1 {
  margin-top: 0;
  font-size: 3.998rem;
}

h2,
.air-h2 {
  font-size: 2.827rem;
}

h3,
.air-h3 {
  font-size: 1.999rem;
}

h4,
.air-h4 {
  font-size: 1.414rem;
}

h5,
.air-h5 {
  font-size: 1.121rem;
}

h6,
.air-h6 {
  font-size: .88rem;
}

small,
.air-small {
  font-size: .707em;
}

/* https://github.com/mrmrs/fluidity */

img,
canvas,
iframe,
video,
svg,
select,
textarea {
  display: block;
  margin-left: auto;
  margin-right: auto;

  max-width: 100%;
}

figcaption {
  text-align: center;
}
.subfigures {
  text-align: center;
}
.subfigures figure {
  float: left;
  width: 50%;
  margin:0;
  display: inline-block;
}
.subfigures img {
  display: inline-block;
  width: 90%;
}
.subfigures figure figcaption {
  display: inline-block;
}

@import url(http://fonts.googleapis.com/css?family=Open+Sans:300italic,300);

body {
  color: #444;
  font-family: 'Open Sans', Helvetica, sans-serif;
  font-weight: 300;
  margin: 6rem auto 1rem;
  max-width: 48rem;
  text-align: justify;
}

/*img {
  border-radius: 50%;
  height: 200px;
  margin: 0 auto;
  width: 200px;
}*/

a,
a:visited {
  color: #3498db;
}

a:hover,
a:focus,
a:active {
  color: #2980b9;
}

pre:not(.sourceCode) {
  background-color: #fafafa;
}
pre {
  padding: 1rem;
  text-align: left;
}

blockquote {
  margin: 0;
  border-left: 5px solid #7a7a7a;
  font-style: italic;
  padding: 1.33em;
  text-align: left;
}

ul,
ol,
li {
  text-align: left;
}

p {
  color: #777;
}

/*
 * Copied from w3schools.com:
 * https://www.w3schools.com/css/css_table.asp
 *
 * Table header colour changed to CGV home style (taken from CGV Powerpoint template)
 */
table {
  border-collapse: collapse;
  width: 100%;
}
table td, table th {
  border: 1px solid #ddd;
  padding: 8px;
}
table tr:nth-child(even){background-color: #f2f2f2;}
/* table tr:hover {background-color: #ddd;} */
table th {
  padding-top: 12px;
  padding-bottom: 12px;
  text-align: left;
  background-color: #10A5D7;
  color: white;
}


</style>
  <div style="overflow:auto;">
  	<p style="float:left;margin:0;"><b>CS4515</b> - 3D Computer Graphics and Animation</p><p style="float:right;margin:0;">Elmar Eisemann, Ricardo Marroqium</p>
  </div>

  <hr>
  <br/>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Basic Graphics Techniques</h1>
</header>
<h1 id="assignment-1---part-1">Assignment 1 - Part 1</h1>
<p>In this deliverable you will combine parts of the weekly exercises into a single unified application. If you have completed the exercises you should be mostly done, except for the Transparency feature describe at the end of this document. We have provided a stripped down version of exercise 3 which you can extend to make it your own. Your application should be a single executable and should support the following features <strong>without recompiling</strong>:</p>
<p>The required tasks are marked at the end of each section by the header “To be implemented”.</p>
<h1 id="scene-loading-from-toml-file">Scene Loading from <code>toml</code> file</h1>
<p>Your application should support loading the scene state, by specifying the path to a <code>toml</code> file (similar to the one used in practical 3.2). A couple of example scene config files are included in the resources directory.</p>
<p>The code to parse the <code>toml</code> file is already included. Please make sure the parser is working as you will be asked to read specific config files during the check-out moment. These files will be made available in Brightspace before the deadline. The name of the <code>toml</code> should be the first argument when calling the application,</p>
<p>e.g., <code>./Master_Assignment1_P1 resources/default_scene.toml</code></p>
<p>For completeness we provide more explanation about the parser below, but you should not have to change this part of the code except to integrate with a UI and the rest of code to be implemented.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="co">// utility function for parsing vec3s</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="bu">std::</span>optional&lt;glm::vec3&gt; tomlArrayToVec3(<span class="at">const</span> toml::array* array) {</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>    <span class="kw">auto</span> len = array-&gt;size();</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>    <span class="cf">if</span> (len != <span class="dv">3</span>) {</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>        <span class="cf">return</span> <span class="bu">std::</span>nullopt;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>    }</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a>    glm::vec3 output {};</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a>    <span class="cf">if</span> (array) {</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a>        <span class="dt">int</span> i = <span class="dv">0</span>;</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true"></a>        array-&gt;for_each([&amp;](<span class="kw">auto</span>&amp;&amp; elem) {</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true"></a>            <span class="cf">if</span> (elem.is_number()) {</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true"></a>                <span class="cf">if</span> (i &gt; <span class="dv">2</span>)</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true"></a>                    <span class="cf">return</span>;</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true"></a>                output[i] = <span class="kw">static_cast</span>&lt;<span class="dt">float</span>&gt;(elem.as_floating_point()-&gt;get());</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true"></a>                i += <span class="dv">1</span>;</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true"></a>            } <span class="cf">else</span> {</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true"></a>                <span class="cf">return</span>;</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true"></a>            }</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true"></a>        });</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true"></a>    }</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true"></a></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true"></a>    <span class="cf">return</span> output;</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true"></a>}</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true"></a><span class="co">// Program entry point. Everything starts here.</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true"></a><span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>** argv) {</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true"></a></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true"></a>    <span class="co">// parse initial scene config</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true"></a>    <span class="kw">auto</span> config_path = <span class="st">&quot;resources/default_scene.toml&quot;</span>;</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true"></a>    toml::table config;</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true"></a>    <span class="cf">try</span> {</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true"></a>        config = toml::parse_file(config_path);</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true"></a>    } <span class="cf">catch</span> (<span class="at">const</span> toml::parse_error&amp; err) {</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true"></a>        <span class="bu">std::</span>cerr &lt;&lt; <span class="st">&quot;Failed to parse &quot;</span> &lt;&lt; config_path &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true"></a>        <span class="cf">return</span> EXIT_FAILURE;</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true"></a>    }</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true"></a></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true"></a>    <span class="co">// read material data, if available</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true"></a>    shadingData.shininess = config[<span class="st">&quot;material&quot;</span>][<span class="st">&quot;shininess&quot;</span>].value&lt;<span class="dt">float</span>&gt;().value_or(shadingData.shininess);</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true"></a>    shadingData.toonDiscretize = config[<span class="st">&quot;material&quot;</span>][<span class="st">&quot;toonDiscretize&quot;</span>].value&lt;<span class="dt">int</span>&gt;().value_or(shadingData.toonDiscretize);</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true"></a>    shadingData.toonSpecularThreshold = config[<span class="st">&quot;material&quot;</span>][<span class="st">&quot;toonSpecularThreshold&quot;</span>].value&lt;<span class="dt">float</span>&gt;().value_or(shadingData.toonSpecularThreshold);</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true"></a>    shadingData.kd = tomlArrayToVec3(config[<span class="st">&quot;material&quot;</span>][<span class="st">&quot;kd&quot;</span>].as_array()).value_or(shadingData.kd);</span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true"></a>    shadingData.ks = tomlArrayToVec3(config[<span class="st">&quot;material&quot;</span>][<span class="st">&quot;ks&quot;</span>].as_array()).value_or(shadingData.ks);</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true"></a></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true"></a>    <span class="co">// read lights</span></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true"></a>    <span class="cf">if</span> (!config.contains(<span class="st">&quot;lights&quot;</span>)) {</span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true"></a>        <span class="bu">std::</span>cerr &lt;&lt; <span class="st">&quot;Lights not provided, using default light&quot;</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true"></a>        lights = <span class="bu">std::</span>vector&lt;Light&gt; {</span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true"></a>            Light { glm::vec3(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">3</span>), glm::vec3(<span class="dv">1</span>) },</span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true"></a>        };</span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true"></a>    }</span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true"></a></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true"></a>    <span class="cf">if</span> (!config[<span class="st">&quot;lights&quot;</span>][<span class="st">&quot;positions&quot;</span>].is_array()) {</span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true"></a>        <span class="bu">std::</span>cerr &lt;&lt; <span class="st">&quot;Light positions must be array of vectors&quot;</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true"></a>        exit(EXIT_FAILURE);</span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true"></a>    }</span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true"></a></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true"></a>    <span class="cf">if</span> (!config[<span class="st">&quot;lights&quot;</span>][<span class="st">&quot;colors&quot;</span>].is_array()) {</span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true"></a>        <span class="bu">std::</span>cerr &lt;&lt; <span class="st">&quot;Light colors must be array of vectors&quot;</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true"></a>        exit(EXIT_FAILURE);</span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true"></a>    }</span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true"></a></span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true"></a>    <span class="dt">size_t</span> num_lights = config[<span class="st">&quot;lights&quot;</span>][<span class="st">&quot;positions&quot;</span>].as_array()-&gt;size();</span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="dt">size_t</span> i = <span class="dv">0</span>; i &lt; num_lights; ++i) {</span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true"></a>        <span class="kw">auto</span> pos = tomlArrayToVec3(config[<span class="st">&quot;lights&quot;</span>][<span class="st">&quot;positions&quot;</span>][i].as_array()).value();</span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true"></a>        <span class="kw">auto</span> color = tomlArrayToVec3(config[<span class="st">&quot;lights&quot;</span>][<span class="st">&quot;colors&quot;</span>][i].as_array()).value();</span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true"></a>        lights.emplace_back(Light { pos, color });</span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true"></a>    }</span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true"></a>    </span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true"></a>    <span class="co">// read camera settings</span></span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true"></a>    <span class="kw">auto</span> look_at = tomlArrayToVec3(config[<span class="st">&quot;camera&quot;</span>][<span class="st">&quot;lookAt&quot;</span>].as_array()).value();</span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true"></a>    <span class="kw">auto</span> rotations = tomlArrayToVec3(config[<span class="st">&quot;camera&quot;</span>][<span class="st">&quot;rotations&quot;</span>].as_array()).value();</span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true"></a>    <span class="dt">float</span> fovY = config[<span class="st">&quot;camera&quot;</span>][<span class="st">&quot;fovy&quot;</span>].value_or(<span class="fl">50.0</span><span class="bu">f</span>);</span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true"></a>    <span class="dt">float</span> dist = config[<span class="st">&quot;camera&quot;</span>][<span class="st">&quot;dist&quot;</span>].value_or(<span class="fl">1.0</span><span class="bu">f</span>);</span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true"></a></span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true"></a>    <span class="co">// read render settings</span></span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true"></a>    <span class="bu">std::</span>string illumination_model = config[<span class="st">&quot;render_settings&quot;</span>][<span class="st">&quot;illumination_model&quot;</span>].value_or(<span class="st">&quot;phong&quot;</span>);</span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true"></a>    <span class="dt">bool</span> shadows = config[<span class="st">&quot;render_settings&quot;</span>][<span class="st">&quot;shadows&quot;</span>].value_or(<span class="kw">false</span>);</span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true"></a>    <span class="dt">bool</span> pcf = config[<span class="st">&quot;render_settings&quot;</span>][<span class="st">&quot;pcf&quot;</span>].value_or(<span class="kw">false</span>);</span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true"></a></span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Illumination model: &quot;</span> &lt;&lt; illumination_model &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true"></a>    </span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true"></a>    <span class="co">// read mesh</span></span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true"></a>    <span class="dt">bool</span> animated = config[<span class="st">&quot;mesh&quot;</span>][<span class="st">&quot;animated&quot;</span>].value_or(<span class="kw">false</span>);</span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true"></a>    <span class="kw">auto</span> mesh_path = <span class="bu">std::</span>string(RESOURCE_ROOT) + config[<span class="st">&quot;mesh&quot;</span>][<span class="st">&quot;path&quot;</span>].value_or(<span class="st">&quot;resources/dragon.obj&quot;</span>);</span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true"></a></span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true"></a>    <span class="co">// YOUR CODE HERE</span></span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true"></a>}</span></code></pre></div>
<h1 id="meshes">Meshes</h1>
<p>Here you specify the geometry to render.</p>
<pre class="toml"><code>[meshes]
path = &quot;resources/meshes&quot;
animated = true # or false</code></pre>
<h2 id="to-be-implemented">To be implemented</h2>
<p>If <code>animated</code> is set to true, then <code>path</code> should be to a folder containing a list of obj files exported from blender. Your application should display the mesh as an animation. Alternatively if <code>animated</code> is set to false then <code>path</code> should be the path to a single <code>.obj</code> file and it should be loaded as a single, static frame.</p>
<h1 id="camera">Camera</h1>
<p>Here you can specify the camera intrinsic (fov) and extrinsic (position/rotation) parameters. This is done by providing a <code>lookAt</code> vector, <code>rotations</code> and <code>distance</code>, as well as a <code>fovY</code> parameter.</p>
<pre class="toml"><code>[camera]
lookAt = [0.0, 0.0, -1.0]
rotations = [0.0, 0.0, 0.0]
dist = 2.0
fovy = 50.0</code></pre>
<p>To actually set the camera position the <code>Trackball</code> class you can use the following snippet.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="co">// fovY, look_at, rotations and dist all parsed from file</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>Trackball trackball { &amp;window, glm::radians(fovY) };</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>trackball.setCamera(look_at, rotations, dist);</span></code></pre></div>
<h2 id="to-be-implemented-1">To be implemented</h2>
<p>For the Camera you do not have to implement anything new but make sure that the correct camera parameters are being loaded (try for example changing the <code>toml</code> file and observing the effect).</p>
<h1 id="material">Material</h1>
<p>Here you can specify the material property of the mesh. For simplicity we will have a single material for the whole scene, and you can specify its params here:</p>
<pre class="toml"><code>[material]
kd = [1.0, 0.0, 0.0]
ks = [0.0, 1.0, 0.0, 1.0]
shininess = 3
toonDiscretize = 4
toonSpecularThreshold = 0.49</code></pre>
<p>Note that <code>kd</code> and <code>ks</code> are RGB values loaded as <code>glm::vec3</code> arrays (see parsing code above).</p>
<h2 id="to-be-implemented-2">To be implemented</h2>
<p>Your application should additionally support modifying the material parameters via the UI and loading them into shaders.</p>
<h1 id="lights">Lights</h1>
<p>Here you specify the data about the lights in the scene. <code>N</code> lights are specified by providing arrays of length <code>N</code> describing the properties of each light. Each light should have each property, even if a light does not have a texture a string needs to be provided (it can be empty however, since it is not used). In this example we only have a single light:</p>
<pre class="toml"><code>[lights]
positions = [[0.4, 1.2, 0.2]]
colors = [[0.9, 0.9, 0.9]]
is_spotlight = [true]
direction = [[0.707, 0.0, 0.707]]
has_texture = [false]
texture_path = [&quot;resources/smiley.png&quot;]
</code></pre>
<h2 id="to-be-implemented-3">To be implemented</h2>
<p>Additionally your application should support adding/removing lights and editing the color and position of lights via the UI. In the given code, the variable <code>selectedLightIndex</code> indicates which one is in use and should be passed to the shaders.</p>
<h1 id="render-settings">Render Settings</h1>
<p>You should be able to specify the rendering settings used in the scene file. An example config is:</p>
<pre class="toml"><code>[render_settings]
diffuse_model = &quot;debug&quot; # or &quot;lambert&quot; or &quot;toon&quot; or &quot;x-toon&quot;
specular_model = &quot;none&quot; # or &quot;phong&quot; or &quot;blinn-phong&quot; or &quot;toon&quot;
shadows = true # or false
pcf = true # or false</code></pre>
<ul>
<li><code>diffuse_model</code> should be a string describing the diffuse material model to use is always one of <code>debug</code>, <code>lambert</code>, <code>toon</code> or <code>x-toon</code>.</li>
<li><code>specular_model</code> should be a string describing the specular material model to use is always one of <code>none</code>, <code>phong</code>, <code>blinn-phong</code> or <code>toon</code></li>
<li>When <code>shadows</code> is set to true you should render shadows using shadow mapping</li>
<li>When <code>pcf</code> is set to true the shadows should be filtered with PCF like in the shadows practical.</li>
</ul>
<h2 id="to-be-implemented-4">To be implemented</h2>
<p>All material models should be implemented with modern OpenGL, as described in practical 3.2. The debug material should show the normals and is already implemented. Your application should also include shadows via Shadow Mapping and PCF.</p>
<p>Your code should support switching between all the options above (material models, shadows and PCG) via the UI, but some test scenes might have them already set, so make sure you can load the settings directly from the file.</p>
<h1 id="transparency-effect">Transparency effect</h1>
<p>This is the only new feature as it was only partially covered by the exercises.</p>
<h2 id="to-be-implemented-5">To be implemented</h2>
<p>Lastly your application should have a separate mode for a transparency effect implemented with depth peeling. It should display a series of semitransparent planes (or quads) behind each other. You should handle at least two layers of transparency. You should implement this feature using depth peeling to extract the semi-transparent planes and then compose them using alpha blending. Moreover, it should support editing the color and opacity of the planes via the UI. Don’t forget to include an option to turn transparency on/off.</p>
<hr />
<h1 id="submission">Submission</h1>
<p>You should submit your code to Brightspace before the assigned deadline. Please make sure to <strong>not</strong> submit your build folder or any executables.</p>
<p>During the practical session on Friday October 4th a TA or lecturer will check you out. Before this day some extra scene files (<code>toml</code>) will be made available in Brightspace via an announcement. You should download these files and place them in your <code>resources</code> folder.</p>
<h2 id="check-out">Check-out</h2>
<p>During the check-out you will run your application from your computer. Make sure you have it compiled and ready to run. You will then be asked to follow some instructions. Some examples of instructions are:</p>
<ul>
<li>run the application with this <code>toml</code> file</li>
<li>turn shadow map off/on</li>
<li>turn shadow map on and PCG off/on</li>
<li>create a new light source and move it around</li>
<li>turn on Lambert mode for diffuse and Blinn-Phong for specular</li>
</ul>
<h2 id="grading">Grading</h2>
<p>Your grade for this deliverable is determined by the check-out procedure and a follow-up inspection of the code.</p>
<p>The grade of Assignment 1 is composed of three parts with equal weights. This current deliverable is Part 1 and is worth 1/3 of the Assignment 1 grade, which is equivalent to 20% of the Final Grade of the course.</p>
<p>As a reminder: to pass the course you need to achieve at least 5.0 in each Assignment 1 and Assignment 2 grades, and your final rounded grade should be at least 6.0.</p>
</body>
</html>
